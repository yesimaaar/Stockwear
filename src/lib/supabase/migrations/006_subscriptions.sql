-- ============================================================================
-- 006_subscriptions.sql
-- Sistema de Suscripciones para StockWear
-- ============================================================================

-- ============================================================================
-- 1. TABLA DE SUSCRIPCIONES
-- ============================================================================
CREATE TABLE IF NOT EXISTS subscriptions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tienda_id BIGINT NOT NULL REFERENCES tiendas(id) ON DELETE CASCADE,
  
  -- Plan y estado
  plan TEXT NOT NULL DEFAULT 'free' CHECK (plan IN ('free', 'professional', 'business')),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'canceled', 'past_due', 'trialing', 'paused')),
  billing_period TEXT NOT NULL DEFAULT 'monthly' CHECK (billing_period IN ('monthly', 'quarterly', 'yearly')),
  
  -- Período actual
  current_period_start TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  current_period_end TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '1 month'),
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  trial_ends_at TIMESTAMPTZ,
  
  -- Contadores de uso (se resetean mensualmente)
  ai_searches_this_month INTEGER DEFAULT 0,
  ai_searches_reset_at TIMESTAMPTZ DEFAULT (DATE_TRUNC('month', NOW()) + INTERVAL '1 month'),
  
  -- Información de pago
  payment_provider TEXT CHECK (payment_provider IN ('mercadopago', 'stripe')),
  payment_provider_id TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Una suscripción por tienda
  CONSTRAINT unique_tienda_subscription UNIQUE (tienda_id)
);

-- Índices para consultas frecuentes
CREATE INDEX IF NOT EXISTS idx_subscriptions_tienda ON subscriptions(tienda_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
CREATE INDEX IF NOT EXISTS idx_subscriptions_plan ON subscriptions(plan);
CREATE INDEX IF NOT EXISTS idx_subscriptions_period_end ON subscriptions(current_period_end);

-- ============================================================================
-- 2. HISTORIAL DE SUSCRIPCIONES (para auditoría)
-- ============================================================================
CREATE TABLE IF NOT EXISTS subscription_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  subscription_id BIGINT NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
  tienda_id BIGINT NOT NULL REFERENCES tiendas(id) ON DELETE CASCADE,
  
  -- Cambio realizado
  action TEXT NOT NULL CHECK (action IN ('created', 'upgraded', 'downgraded', 'canceled', 'renewed', 'payment_failed', 'reactivated')),
  previous_plan TEXT,
  new_plan TEXT,
  previous_period TEXT,
  new_period TEXT,
  
  -- Detalles del pago (si aplica)
  amount NUMERIC(12, 2),
  currency TEXT DEFAULT 'COP',
  payment_reference TEXT,
  
  -- Metadatos
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_subscription_history_subscription ON subscription_history(subscription_id);
CREATE INDEX IF NOT EXISTS idx_subscription_history_tienda ON subscription_history(tienda_id);

-- ============================================================================
-- 3. TABLA DE USO MENSUAL (tracking detallado)
-- ============================================================================
CREATE TABLE IF NOT EXISTS subscription_usage (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tienda_id BIGINT NOT NULL REFERENCES tiendas(id) ON DELETE CASCADE,
  
  -- Período
  month_year TEXT NOT NULL, -- formato: '2026-01'
  
  -- Contadores
  ai_searches INTEGER DEFAULT 0,
  products_created INTEGER DEFAULT 0,
  sales_count INTEGER DEFAULT 0,
  catalog_views INTEGER DEFAULT 0,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT unique_tienda_month UNIQUE (tienda_id, month_year)
);

CREATE INDEX IF NOT EXISTS idx_subscription_usage_tienda ON subscription_usage(tienda_id);

-- ============================================================================
-- 4. FUNCIONES HELPER
-- ============================================================================

-- Función para obtener la suscripción de una tienda
CREATE OR REPLACE FUNCTION get_tienda_subscription(p_tienda_id BIGINT)
RETURNS TABLE (
  id BIGINT,
  plan TEXT,
  status TEXT,
  billing_period TEXT,
  current_period_end TIMESTAMPTZ,
  ai_searches_this_month INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.id,
    s.plan,
    s.status,
    s.billing_period,
    s.current_period_end,
    s.ai_searches_this_month
  FROM subscriptions s
  WHERE s.tienda_id = p_tienda_id
  LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Función para incrementar contador de búsquedas IA
CREATE OR REPLACE FUNCTION increment_ai_searches(p_tienda_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
  v_subscription subscriptions%ROWTYPE;
  v_limit INTEGER;
BEGIN
  -- Obtener suscripción
  SELECT * INTO v_subscription
  FROM subscriptions
  WHERE tienda_id = p_tienda_id;
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- Resetear contador si es nuevo mes
  IF v_subscription.ai_searches_reset_at < NOW() THEN
    UPDATE subscriptions
    SET 
      ai_searches_this_month = 1,
      ai_searches_reset_at = DATE_TRUNC('month', NOW()) + INTERVAL '1 month',
      updated_at = NOW()
    WHERE tienda_id = p_tienda_id;
    RETURN TRUE;
  END IF;
  
  -- Verificar límite según plan
  v_limit := CASE v_subscription.plan
    WHEN 'free' THEN 0
    WHEN 'professional' THEN 100
    WHEN 'business' THEN -1 -- ilimitado
    ELSE 0
  END;
  
  -- Si es ilimitado o está dentro del límite, incrementar
  IF v_limit = -1 OR v_subscription.ai_searches_this_month < v_limit THEN
    UPDATE subscriptions
    SET 
      ai_searches_this_month = ai_searches_this_month + 1,
      updated_at = NOW()
    WHERE tienda_id = p_tienda_id;
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Función para verificar si puede crear más productos
CREATE OR REPLACE FUNCTION can_create_product(p_tienda_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
  v_plan TEXT;
  v_limit INTEGER;
  v_current INTEGER;
BEGIN
  -- Obtener plan
  SELECT plan INTO v_plan
  FROM subscriptions
  WHERE tienda_id = p_tienda_id;
  
  IF NOT FOUND THEN
    v_plan := 'free';
  END IF;
  
  -- Límites por plan
  v_limit := CASE v_plan
    WHEN 'free' THEN 50
    WHEN 'professional' THEN 500
    WHEN 'business' THEN -1
    ELSE 50
  END;
  
  IF v_limit = -1 THEN
    RETURN TRUE;
  END IF;
  
  -- Contar productos actuales
  SELECT COUNT(*) INTO v_current
  FROM productos
  WHERE tienda_id = p_tienda_id AND estado = 'activo';
  
  RETURN v_current < v_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Función para verificar límite de almacenes
CREATE OR REPLACE FUNCTION can_create_warehouse(p_tienda_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
  v_plan TEXT;
  v_limit INTEGER;
  v_current INTEGER;
BEGIN
  SELECT plan INTO v_plan
  FROM subscriptions
  WHERE tienda_id = p_tienda_id;
  
  IF NOT FOUND THEN
    v_plan := 'free';
  END IF;
  
  v_limit := CASE v_plan
    WHEN 'free' THEN 1
    WHEN 'professional' THEN 3
    WHEN 'business' THEN -1
    ELSE 1
  END;
  
  IF v_limit = -1 THEN
    RETURN TRUE;
  END IF;
  
  SELECT COUNT(*) INTO v_current
  FROM almacenes
  WHERE tienda_id = p_tienda_id AND estado = 'activo';
  
  RETURN v_current < v_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Función para verificar límite de usuarios
CREATE OR REPLACE FUNCTION can_create_user(p_tienda_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
  v_plan TEXT;
  v_limit INTEGER;
  v_current INTEGER;
BEGIN
  SELECT plan INTO v_plan
  FROM subscriptions
  WHERE tienda_id = p_tienda_id;
  
  IF NOT FOUND THEN
    v_plan := 'free';
  END IF;
  
  v_limit := CASE v_plan
    WHEN 'free' THEN 1
    WHEN 'professional' THEN 5
    WHEN 'business' THEN 15
    ELSE 1
  END;
  
  SELECT COUNT(*) INTO v_current
  FROM usuarios
  WHERE tienda_id = p_tienda_id AND estado = 'activo';
  
  RETURN v_current < v_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- 5. TRIGGER PARA CREAR SUSCRIPCIÓN FREE AL CREAR TIENDA
-- ============================================================================
CREATE OR REPLACE FUNCTION create_default_subscription()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO subscriptions (tienda_id, plan, status, billing_period)
  VALUES (NEW.id, 'free', 'active', 'monthly')
  ON CONFLICT (tienda_id) DO NOTHING;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_create_default_subscription ON tiendas;
CREATE TRIGGER trigger_create_default_subscription
  AFTER INSERT ON tiendas
  FOR EACH ROW
  EXECUTE FUNCTION create_default_subscription();

-- ============================================================================
-- 6. RLS POLICIES
-- ============================================================================
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscription_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscription_usage ENABLE ROW LEVEL SECURITY;

-- Policies para subscriptions
DROP POLICY IF EXISTS "Users can view their store subscription" ON subscriptions;
CREATE POLICY "Users can view their store subscription"
  ON subscriptions FOR SELECT
  USING (tienda_id = get_my_tienda_id());

DROP POLICY IF EXISTS "Only admins can update subscription" ON subscriptions;
CREATE POLICY "Only admins can update subscription"
  ON subscriptions FOR UPDATE
  USING (tienda_id = get_my_tienda_id())
  WITH CHECK (tienda_id = get_my_tienda_id());

-- Policies para subscription_history
DROP POLICY IF EXISTS "Users can view their subscription history" ON subscription_history;
CREATE POLICY "Users can view their subscription history"
  ON subscription_history FOR SELECT
  USING (tienda_id = get_my_tienda_id());

-- Policies para subscription_usage
DROP POLICY IF EXISTS "Users can view their usage" ON subscription_usage;
CREATE POLICY "Users can view their usage"
  ON subscription_usage FOR SELECT
  USING (tienda_id = get_my_tienda_id());

-- ============================================================================
-- 7. CREAR SUSCRIPCIONES PROFESIONAL PARA TIENDAS EXISTENTES
-- ============================================================================
-- Para tiendas existentes, asignamos plan profesional como regalo de early adopter
INSERT INTO subscriptions (tienda_id, plan, status, billing_period, current_period_end)
SELECT 
  id, 
  'professional', 
  'active', 
  'yearly',
  NOW() + INTERVAL '1 year'  -- 1 año gratis como early adopter
FROM tiendas
WHERE NOT EXISTS (
  SELECT 1 FROM subscriptions WHERE subscriptions.tienda_id = tiendas.id
)
ON CONFLICT (tienda_id) DO NOTHING;
